Шаблоны в Java (generics)
Начиная с версии Java 5.0 в языке появился механизм обобщённого программирования — шаблоны, внешне близкие к шаблонам C++. С помощью специального синтаксиса в описании классов и методов можно указать параметры-типы, которые внутри описания могут использоваться в качестве типов полей, параметров и возвращаемых значений методов.

Допускается обобщённое объявление классов, интерфейсов и методов. Кроме того, синтаксис поддерживает ограниченные объявления типов-параметров: указание в объявлении конструкции вида <T extends A & B & C...> требует, чтобы тип-параметр T реализовывал интерфейсы A, B, C и так далее.

В отличие от шаблонов C#, шаблоны Java не поддерживаются средой исполнения — компилятор просто создаёт байт-код, в котором никаких шаблонов уже нет. Реализация шаблонов в Java принципиально отличается от реализации аналогичных механизмов в C++: компилятор не порождает для каждого случая использования шаблона отдельный вариант класса или метода-шаблона, а просто создаёт одну реализацию байт-кода, содержащую необходимые проверки и преобразования типов. Это приводит к ряду ограничений использования шаблонов в программах на Java.

Проверка принадлежности к классу
В Java можно явно проверить, к какому классу принадлежит объект.
Выражение foo instanceof Foo равно true, если объект foo принадлежит классу Foo
или его наследнику, или реализует интерфейс Foo (или, в общем виде,
наследует класс, который реализует интерфейс, который наследует Foo).

Далее функция getClass()[док. 10], определённая для всех объектов,
выдаёт объект типа Class<?>. Для каждого класса создаётся не более
одного описывающего его объекта типа Class, поэтому эти объекты можно
сравнивать. Так, например, foo.getClass() == bar.getClass() будет истинно, если объекты foo и bar принадлежат к одному классу.

Кроме того, объект типа Class<?> любого типа можно получить так:
Integer.class, Object.class.

Прямое сравнение классов не всегда является оптимальным средством
проверки на принадлежность к классу. Зачастую вместо него используют функцию isAssignableFrom(). Эта функция определена у объекта типа Class и принимает объект типа Class<?> в качестве параметра. Таким образом, вызов Foo.class.isAssignableFrom(Bar.class) вернёт true в случае, если Foo является предком класса Bar. Так как все объекты являются потомками типа Object, вызов Object.class.isAssignableFrom() всегда вернёт true.

В паре с упомянутыми функциями объекта типа Class используются также
функции isInstance[док. 11] (эквивалентно instanceof), а также cast()
(преобразует параметр в объект выбранного класса).

Обработка ошибок
Обработка ошибок в Java похожа на обработку ошибок в C++
за исключением необходимости в блоке finally. Данное
отличие обусловлено тем, что Java не может придерживаться концепции RAII из-за наличия сборщика мусора, а автоматическое освобождение ресурсов в деструкторе может идти в непредсказуемом порядке через произвольные промежутки времени.

Осуществляется обработка ошибок с помощью операторов try, catch и finally. Выбрасываемая ошибка описывается объектом определённого класса, наследующегося от Throwable[док. 12] и соответствующего типу ошибки. Внутрь блока try помещается код, который может выбросить исключение, а блок catch отлавливает заданные программистом типы ошибок. При этом можно указывать более одного блока catch для обработки различных классов ошибок, или multi-catch для обработки нескольких ошибок. Блок finally является необязательным, но при наличии выполняется независимо от возникновения ошибки и предназначен для освобождения выделенных в ходе работы блока try ресурсов.

Начиная с Java 7 поддерживается интерфейс AutoCloseable[док. 13], который позволяет реализовывать классы, автоматически освобождающие ресурсы. Объекты подобных классов требуется создавать в круглых скобках перед блоком try. Простым примером автоматического освобождения ресурсом может служить чтение содержимого файла:

Java придерживается концепции обязательного указания классов ошибок, которые может выбросить метод. Делается это с помощью ключевого слова throws после описания метода. Если в методе не указать класс исключения (или его предка), которое может быть выброшено из метода, то это вызовет ошибку компиляции. Концепция должна была позволить делать код самодокументируемым, обозначая, какие исключения может выбросить тот или иной метод, но на практике редко себя оправдывает, поскольку в силу разных обстоятельств программист может указать в качестве выбрасываемого исключения класс Exception либо заключить проблемные части метода в блок try…catch для игнорирования отдельных ошибок, либо — в блок try…finally, скрывая все возможные ошибки. Недостатком концепции также является и то, что программист сам должен определять и прописывать исключения, которые может выбрасывать метод[76].

Пространство имён

Стиль этого раздела неэнциклопедичен или нарушает нормы литературного русского языка.
Статью следует исправить согласно стилистическим правилам Википедии.
Основная статья: Пространство имён (программирование)
Идея пространств имён воплощена в Java-пакетах.

Название Java-пакета — латиница (нижний и верхний регистр) с цифрами (не первые в строке) и знаком подчёркивания (не первые и не последние), не являющаяся инструкциями языка (прим. if, null), разделённая точками.

Пакеты содержат классы, интерфейсы, перечисления, аннотации (и т. д.), имена которых — латиница (нижний и верхний регистр) с цифрами (не первые в строке). Публичный класс, интерфейс (и т. д.) в одном файле может быть только один. Имя публичного класса, интерфейса (и т. д.) в файле должно совпадать с названием файла. Каждый класс имеет своё пространство имён для функций, переменных и подклассов, подинтерфейсов (и т. д.), причём получить подкласс класса можно с помощью OuterClass.InnerClass, а можно с помощью OuterClass$InnerClass, поэтому использование символа доллара в названии класса не рекомендуется.